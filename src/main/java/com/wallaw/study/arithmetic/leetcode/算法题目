常用基础方法：
toCharArray() //获得字符串对应的char数组
Arrays.sort()  //数组排序
Arrays.toString(char[] a) //数组转成字符串
charAt(int x) //获得某个索引处的字符
length() //字符串长度
length //数组大小
substring(int beginIndex)  //从index位置开始的子字符串
substring(int beginIndex, int endIndex) // begin到end的子字符串
Integer.valueOf() //string to integer
String.valueOf() /integer to string

链表中的node
class Node {
	int val;
	Node next;

	Node(int x) {
		val = x;
		next = null;
	}
}
class TreeNode{
	int value;
	TreeNode left;
	TreeNode right;
}


练习题文章：https://blog.csdn.net/hnulwt/article/details/45822517#

1. 给出一个排序好的数组和一个数，求数组中连续元素的和等于所给数的子数组

2. 输入一个字符串，打印出该字符串中字符的所有排列。如输入字符串 abc, 则打印字符a、b、c所能排列出来的所有字符串abc、acb、bac、bca、cab和cba。

3. 输入一个整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如 输入数组{3,32,321}，则打印出这3个数字能
排成的最小数字为 321323.
int[] num={1,5,9,13,442,44,6,21,211};

4. 输入一个整数数组，数组里有整数也有负数。数组中一个或连续的多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n).

5. 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数。在该栈中，调用min、push及pop的时间复杂度都是O（1）。

6. 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如：输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度
的一半，因此输出2.
int[] num = {1,2,2,2,2,2,2,4,2,4,6,4,2,6,8,2,7,7};

7. 题目:输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。
例如序列1、2、3、4、5是某栈的压栈序列，序列4、5、3、2、1是该压栈序列对应的一个弹出序列，但4、3、5、1、2就不可能是该压栈序列的弹出序列。


8. 题目:从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2~10为数字本身，A为1, J为11, Q为12，K为13，而大、小王可以看成任意数字。

9. 题目:我们把只包含因子2、3和5的数称作丑数(Ugly Number).求按从小到大的顺序的第1500个丑数。例如6、8都是丑数，但14不是，因为它包含因子7。习惯上我们把1当做第一个丑数。

10. LeetCode 151. 翻转字符串里的单词给定一个字符串，逐个翻转字符串中的每个单词。
    示例 1：
    输入: “the sky is blue”  输出: “blue is sky the”
    输入: " hello world! "     输出: “world! hello”

11. LeetCode 206. 反转链表 反转一个单链表。
    示例: 输入: 1->2->3->4->5->NULL    输出: 5->4->3->2->1->NULL

12. Leetcode 142.环形链表，给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。
为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。
说明：不允许修改给定的链表

13. LeetCode 230. 二叉搜索树中第K小的元素 这里根据二叉搜索树的性质:中序遍历后其元素值由小到大排序得出。

14. LeetCode 7. 整数反转
给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。
示例 1:
输入: 123
输出: 321

示例 2:
输入: 120
输出: 21
    注意:假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。

